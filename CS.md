# OS
* [인터럽트, 시스템 콜](https://velog.io/@klm03025/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C)
* [프로세스, 스레드 설명 유튜브](https://www.youtube.com/watch?v=iks_Xb9DtTM)
* [프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

> Process  
> 프로그램이 실행되는 상태 최소 1개의 thread 를 가짐  
> * Process 생명주기
>   1. 프로세스 생성을 위한 공간을 할당하고 PCB(Process Control Block)를 생성 및 초기화하며, 실제메모리를 가상화한 가상메모리를 할당받음  
>      이때 PCB의 프로세스 상태값을 New로 설정
>   2. 프로세스 초기화, 코드, 데이터, 스택 등 초기메모리 영역 설정 및 프로그램카운터가 첫 명령어 주소를 가르키도록 설정
>   3. 초기화가 완료되면 프로세스 상태를 Ready로 변경하고, Ready Queue에 등록
>   4. 디스패처에 의해 선택된 순서가 되면 프로세스가 실행되고 상태를 Running으로 변경
       (디스패처는 준비상태의 프로세스 중 실행할 프로세스를 선택하는 기능을 수행)
>   5. 시간 할당량이 지나면 Ready상태로 변경, 입출력 요청이 발생하면 Waiting 또는 Block 상태가 되었다가, 끝나면 Ready상태로 변경  
       (입출력 요청 때 NonBlock일 경우 Wait 없이 계속실행)
>      (실행에서 상태가 변경될 때, Context Switching이 일어나고, 이 때 PCB에 진행중이던 정보를 저장)
>   7. Ready Queue에 다시 등록되었다가, 순서가 되면 다시 실행되고 모든 작업이 완료되면 프로세스가 종료
     운영체제는 PCB를 삭제하고, 할당한 가상메모리를 해제, 종료 코드는 부모프로세스에게 전달

> PCB(Process Control Block)  
> 운영체제가 프로세스를 관리하기 위한 정보를 포함하는 공간  
> * 내부 구조
>   * 프로세스의 식별자(Process ID)
>   * 프로세스 상태(Process State)
>   * 프로그램 카운터(실행할 명령어의 주소를 카르키는 포인터),
>   * 레지스터 상태(실행중인 프로세스의 CPU의 레지스터 상태, Context Switching이 일어날 때 진행중인 작업을 저장)
>   * 스케줄링 정보(우선순위, 할당된 CPU시간 정보 등)
>   * 메모리 관리 정보(가상메모리 주소 공간 또는 실제 메모리 할당 정보 등)
>   * 자원할당 정보(메모리, 파일, IO장치 등 정보 및 위치, 상태 여부)
>   * 계정 정보(프로세스 실행 시간, CPU 사용량, 입출력 작업 수 등) 



> Thread  
> 스레드는 프로세스를 구성하는 작은 실행 단위로서, CPU에서 처리되기 위한 단위입니다. 프로세스는 스레드의 집합  
> 모든 프로세스는 하나 이상의 스레드를 가지고 있음

> TCB(Thread Control Block)
> 스레드의 관리 및 정보를 저장하는 구조체
> 리눅스에서는 Task Control Block으로 불리기도하고,  
> Window에서는 ETHREAD(Executive Thread Object), KTHREAD(Kernel Thread Object)로 사용된다.  
> TCB의 상태는 실행, 준비, 대기, 종료가 있으며,  
> 프로세스의 상태는 스레드의 상태를 따라가는데 이때 스레드 상태의 우선순위는 실행, 준비, 대기, 종료 순이다.  
> 즉 1개라도 실행이면 실행, 실행을 제외하고 1개라도 준비라면 준비,... 방식이다.


> fork
> 프로세스 생성을 위한 방법 중 하나
> 프로세스를 복제해서 프로세스를 생성 비용을 줄이는 방법
> 복제 대상인 프로세스와 부모자식 관계를 가짐
> 예) 크롬에서 새로운 탭 생성

> exec
> 기존 프로세스를 새로운 프로세스로 대체하는 방법
> PCB를 재활용하고 사용자 영역의 데이터는 초기화해서 새로운 프로세스로 변경
> 기존 PID 및 부모를 계승함

### 스케줄러
> 고수준 스케줄러  
> 새로운 프로세스를 우선순위, 리소스 현황 등을 고려한 실행 결정단계  

> 중간수준 스케줄러
> 메모리에 올라온 프로세스 중 메모리 스왑 인, 아웃을 하는 단계
> 주로 메모리 부족 시 실행

> 저수준 스케줄러 
> 메모리에 올라온 프로세스 중 준비 상태의 프로세스를 실행 시키는 단계
> 실제로는 스레드 단위로 진행


### IPC(inter-process call)
> 목적  
> * 데이터 공유: 프로세스간의 데이터 공유
> * 프로세스간 통신: 서로 상호작용을 위한 통신
> * 동기화: 데이터 접근 및 수정 시 충돌 방지

> 기법
> * 파이프: 단방향 통신 채널로 부모와 자식프로세스 간에 사용
> * 메시지 큐: 양방향 통신, 프로세스 간 통신에 사용
> * 공유 메모리: 두개 이상의 프로세스가 같은 메모리 영역을 공유해서 사용(전역 변수와 비슷)
> * 네트워크: 네트워크 통신을 활용한 방법, 소켓 및 RPC(remote procedure call) 등을 사용

#### 동시성 제어
* [뮤텍스, 세마포어 차이](https://heeonii.tistory.com/14)
> 뮤텍스
> * 한번에 하나의 스레드만이 락을 획득 할 수 있게 하는 방법
> * 다른 스레드가 락을 획득하려면 사용중인 스레드가 락을 해제해야 함
> * 이진 세마포어로 구현  

> 세마포어
> * 동시에 허용하는 스레드 수를 지정해서 사용하는 방법
> * N개의 스레드 작업을 생성해 놓고, 과부하를 막기 위해 특정 스레드 수 만 동작하도록 제어할 수 있음
> * 공유변수에 값을 변화시키는 것에는 동기화 이슈때문에 적합하지 않음(뮤텍스를 활용)
> * 특정 자원에 접근을 제어하고 동기화 하는데 사용


### 메모리
> 절대주소,  상대주소
> |구분|절대주소|상대주소
> |----|-------|-------|
> 관점|메모리 관리자 입장|사용자 프로세스 입장
> 주소시작|물리주소 0번지|물리주소와 상관없이 항상 0번지
> 주소공간|물리 주소(실제주소) 공간|논리 주소 공간(가상메모리)
> 
> 절대 주소는 특별한 변환 과정 없이 바로 접근,  
> 상대주소는 메모리 관리자의 재배치 레지스터를 통해 절대주소로 변환되어 접근

##### 가상메모리
> * 사용이유
>   * 메모리 의존성 제거: 시스템 사양에 따라 메모리 용량이 다른 부분을 가상메모리를 통해 극복  
                         메모리 관리자가 1차메모리와 2차메모리의 swap영역을 합쳐서 물리 메모리보다 큰 용량 사용 가능
>   * 프로세스 격리: 프로세스 간 상호 격리로 보안 강화, 잘못된 접근으로 인한 메모리 충돌 방지
>   * 메모리 관리: 메모리 관리자가 매핑 테이블을 이용, 메모리 관리 용이
>  
> * 매핑 테이블을 사용해서 프로세스의 가상메모리와 물리 메모리 주소를 연결
> * 메모리 분할 방식으로 세그먼테이션, 페이징을 혼용해서 사용
> * 세그먼테이션: 가변 분할방식으로 논리적 크기에 따라 메모리 공간을 분리하는 방법으로,  
>                프로세스 종료시 메모리 외부 단편화가 발생함(각각 프로세스마다 사용 공간이 다름으로, 빈 공간 발생)
> * 페이징: 고정 분할방식으로 일정한 크기에 따라 메모리 공간을 분리하는 방법으로,  
>           20kb를 제한으로 지정했을 시 20kb로 나누고 나머지에 대해 최소 20kb 공간을 잡아야 하므로 빈공간이 발생 이를 메모리 내부 단편화라고함


### 시스템 콜(system call)
> 운영체제가 커널에 접근하기 위한 인터페이스,  
> 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용  
> 예) I/O 작업 등
>
> * modebit: 커널모드, 유저모드 구분을 위한 CPU 레지스터에 저장공간 0커널, 1유저모드




# Computer

#### CPU
CPU 구조
* ALU: 산술논리 연상장치
* 레지스터: 임시 저장장치
* 제어장치: 제어신호를 다루는 명령어 해석 장치
대표적인 아키텍처
* CISC (Complex Instruction Set Computer)
	* x86-64 에 사용
	* 복잡하고 다양한 명령어 지원
	* 가변메모리 사용
	* 파이프라인 활용이 어려움
* RISC (Reduced Instruction Set Computer)
	* 명령어 종류가 적음
	* 고정 길이 사용
	* 1클럭 내외로 명령어 수행
	* 파이프라인 활용이 쉬움
#### 캐시 메모리
> CPU의 레지스터와 주기억장치(RAM)의 사이에서 속도 차이를 줄이기 위한 메모리
> * CPU의 사용 데이터를 참조 지역성의 원리로 예측해서 미리 데이터를 적재
> 	* 최근 접근 했던 메모리
> 	* 인접 메모리

#### 플레시 메모리
> SSD, SD카드, USB 등 보조기억 장치에 많이 사용
> * cell 이라는 저장 단위를 가지며, cell에 몇 개의 비트를 가지냐에 따라 SLC, MLC, TLC, QLC 등으로 구분
> * cell 이 가진 비트 수에 따라 수명, 속도, 비용이 결정 됨 성능 및 수명은 작은 쪽이 높고, 가격은 클수록 저렴
> * 셀 > 페이지 > 블록 > 플레인 > 다이 의 순서로 각각이 모이면 다음 그룹의 이름으로 불림
> * 읽기에는 페이지, 삭제에는 블록 단위가 사용됨
> * 페이지는 3가지 상태를 가짐 Free(사용 전), Valid(사용 됨), inValid(사용하지않음)
> * 덮어쓰기는 불가능 하기 때문에, 데이터 수정은 새롭게 저장 됨
> * 블록에 있는 페이지 들 중 사용되지 않은 데이터는 가비지 컬렉션을 통해, 새로운 블럭에 사용되는 데이터가 복사되고, 해당 블럭을 삭제하는 방식으로 삭제 됨


#### RAID
> 복수의 저장 장치를 특정 방식으로 묶어서 사용하는 방법
> * RAID 0
> 	* 데이터를 나열해서 번갈아 가며 저장하는 방식
> 	* 병렬 처리로 입출력 속도 향상
> 	* 고장 발생 시 데이터가 손실
> * RAID 1
> 	* 미러링을 생성(복사본)
> 	* 복사본을 생성하므로 용량 감소, 쓰기 속도 감소
> 	* 고장 발생 시 복구 가능
> * RAID 4
> 	* 오류 복구 및 검출을 하기 위한 디스크를 지정해서  
> 	  RAID1 보다 저비용으로 복구를 가능하게 하는 방법
> 	* 데이터 쓰기 시 오류 복구 및 검출을 위한 디스크에 병목 현상 발생
> * RAID 5
> 	* 오류 복구 및 검출 데이터를 분산 해서 저장하는 방식
> * RAID 6
> 	* RAID5의 오류 복구 및 검출 데이터를 복사해서 다른 디스크에 저장하는 방식

#### 입출력
> 입출력의 종류
> * 프로그램 입출력: CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀
> 	* CPU가 입출력 레지스터를 찾는 방법
> 		* 메모리 맵 입출력: 메모리에 접근하기 위한 주소공간과 입력장치에 접근하기 위한 주소공간을 동일하게 취급하는 방법. 
> 		  메모리 공간 중 일부를 입출력 포트에 할당하여 사용, 동일한 명령어를 사용해서 CPU 로직이 단순
> 		* 고립형 입출력: 분리된 주소 공간을 사용하는 방법, 입출력 전용 명령어 사용 필요
> 	* 입출력 장치의 상태를 폴링(polling)방식을 사용해서 확인: 주기적으로 상태확인
> * 인터럽트 기반 입출력
> 	* 폴링 방식이 아닌 장치 컨트롤러가 CPU에 요청을 보내서 상태변경을 확인
> 	* PIC(programmable interrupt controller)를 통해 우선순위를 결정해서 CPU에 전달.  
> 	  NMI(Non-Maskable Interrupt)는 처리하지 않음: 심각한 하드웨어 오류
> * DMA(Direct Memory Access) 입출력
> 	* CPU를 거치지 않고 입출력장치가 메로리에 접근하는 방식
> 	* DMA 컨트롤러 필요
> 		* CPU에게 입출력 작업을 위탁받아서 대신 처리
> 		* 완료 시 인터럽트를 통해 CPU에 알림
> 		* CPU와 시스템 버스를 같이 사용하기 때문에, 상황에 따라 피해 사용하거나 사용을 공지하고 사용
> 		* 입출력 용 입출력 버스를 사용해서 입출력 장치 간의 사용은 별도의 버스를 사용(PCI, PCI express 등 )
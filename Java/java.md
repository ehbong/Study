# JAVA

> JRE(Java Runtime Environment): 자바 실행 환경
> * JVM, 표준 클래스 라이브러리

> JDK(Java Development Kit): 자바 개발 키트
> * JRE, 컴파일러, 디버거 등의 개발도구

> ****메모리 영역****
> * 메소드 영역: 모든 클래스 정보와 클래스의 정적 필드, 상수, 메소드 데이터를 저장
> * 힙 영역: 객체의 인스턴스와 배열을 저장(가비지 컬렉션의 주요 대상이 되는 영역)
> * 스택 영역: 실제로 프로그램이 실행되는 과정에 필요한 데이터를 스택 구조로 관리하는 영역
>            메소드 단위로 프레임이라는 내부 스택 구조를 생성하고 각각 필요한 정보를 메소드 영역 및 힙 영역에서 가져와서 실행 됨

> ****형변환****  
> int를 float로 형 변환 시 float의 가수 영역이 23비트이므로 23비트를 초과하는 수를 형변환 하면 값의 정밀도를 보장할 수 없다.
> 따라서 int를 실수로 변경 시 명확하게 범위를 특정할 수 없다면 double을 사용해서 값의 손실을 방지 할 수 있다.

* [maven 기본 세팅](https://byul91oh.tistory.com/304)



* [동시성이슈 해결](https://thalals.tistory.com/370)

* [DI, IOC 간단 설명](https://velog.io/@gillog/Spring-DIDependency-Injection)


<br><br>
----
### 상속, 구현
* 업 캐스팅, 다운 캐스팅
```java
 // TestA 를 상속받은 TestB, TestB를 상속받은 TestC가 있을 때
 TestA a = new TestA();
 TestA b = new TestB();
 TestA c = new TestC();
```
> 업 캐스팅  
> * 위 코드 처럼 A에 대입했을 때, 자식 클래스 객체가 부모 클래스로 형변환 되는 것
> * 형변환 되면서 자식 클래스만 가지고 있던 필드 및 메소드의 접근이 제한
```java
 TestB b2 = (TestB)b;
```
> 다운 캐스팅  
> * 업캐스팅 된 객체를 명시적으로 지정해서 다시 자식클래스로 형변환 하는 것
> * 기존 자식 클래스만 가지고 있던 필드와 메소드들을 복구
> * 형 변환 시, 실제 자식클래스의 객체가 아닌 부모 클래스의 객체를 형변환 시 오류 발생(instanceof 로 확인 필요)

> 추상 클래스 상속과, 구현(인터페이스) 차이
> * 추상 클래스는 추상 메소드 외에 일반 메소드를 생성 가능
> * 자바에서 상속은 다중 상속 불가
> * 인터페이스는 추상 메소드와 필드만 가능
> * 인터페이스는 형식만 있기 때문에 구현체에서 실제 동작을 구현해야하고, 이로 인해 다중 인터페이스 구현이 가능.



<br><br>
----
#### 정적 변수, 메소드
> * 정적 메소드는 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재
> * 정적 메소드 및 블록 사용 시 주의
>   * 정적 메소드 및 블록은 클래스 객체가 생성 되기 전에 생성 되므로, 클래스 내 인스턴스 필드 및 메소드에 접근할 수 없음
>   * 접근 하려면 블륵 내에서 new키워드로 클래스 객체를 생성 후 접근 가능
>   * GC가 동작하지 않으므로, collection 변수를 사용할 때는 주의 필요(메모리 무한 점유 발생)


#### 접근 제한자
> 아래로 갈수록 제한이 강화
> |접근제한|적용대상|접근금지 대상|
> |----|----|----|
> |public|클래스,필드,생성자,메소드|없음|
> |protected|필드,생성자,메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
> |default|클래스,필드,생성자,메소드|다른 패키지에 소속된 클래스|
> |private|필드,생성자,메소드|모든 외부 클래스|


### 어노테이션  
> 어노테이션 용도  
> * 컴파일러 지시: @override, @Deprecated
> * 런타임 처리: @RequestMapping, @Bean
> * 코드 분석 및 문서화: @Author, @Version


### 컬렉션
> HashSet 에서 중복을 비교할 때, 객체의 hashCode, equals 메소드로 확인을 하기 때문에,
> 동일한 값을 가지는 객체를 저장하지 않으려면 두 메소드를 override 해서 구현하면 된다.

### 제네릭  
> 제네릭 사용 이유  
> * 타입 안정성: 컴파일러의 타입체크
> * 타입 변환 감소: 컴파일러에게 타입을 지정해서 불필요한 형변환을 줄일 수 있음
> * 재사용성과 유연성 증가: 다양한 타입을 수용할 수 있음 


> 문자열 결합  
> * String: 짧은 문자열 결합에 사용(+ 로 결합할 때 마다 메모리 복사가 이루어져서, GC의 부하가 발생)
> * StringBuilder: 스레드의 안전여부와 상관없이 사용할 때 사용(메모리 복사를 하지 않음, 메소드 내부 변수 등)
> * StringBuffer: 스레드에 안전이 필요하거나 필요한지 모를 때 사용(메모리 복사 하지 않음, 클래스의 Static 문자열 또는 싱글톤 클래스의 문자열 등)


### 멀티스레드
* [멀티스레드 예제](https://withhamit.tistory.com/522)
> Thread 클래스
> * 스레드를 직접적으로 생성하고 제어하는 클래스
> * start 메소드를 호출하여 스레드를 실행
> * 상속 받아서 run 메소드를 오버라이드 해서 새로운 동작을 구현할 수 있음
```java
class MyThread extends Thread {
    @Override
    public void run() {
        // 스레드 동작을 정의
    }
}
```
> Runnable 인터페이스
> * Thread 클래스를 상속받지 않고 스레드를 사용하기 위한 인터페이스
> * 인터페이스 구현체 클래스를 생성하고 run 메소드를 오버라이드 해서 새로운 동작을 구현할 수 있음
> * Thread 클래스의 생성자에 매개변수로 전달해서 스레드 객체를 생성할 수 있음
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 스레드 동작을 정의
    }
}

// 스레드 생성 및 실행
Thread thread = new Thread(new MyRunnable());
thread.start();

```


#### Elixir 의 특징
> 패턴매칭
> * 엘릭서에서 a = 1 는 단순 대입이 아닌 패턴매칭이다.
```elixir
a = 1
1
1 = a
1
2 = a
```
> 1. a = 1 은 변수에 1을 매칭(대입) 하면서 같은 값을 만든다
> 2. 1 = a 는 1과 a가 같은 지 확인한다.
> 3. 2 = a 는 2와 a가 같은지 확인한다. 다르므로 오류가 발생한다.
> 4. 변수가 좌변에 있을 때는 대입과 매칭이 동시에 이루어진다.

> 불변성
> * 일반적인 프로그래밍 언어와 다르게 엘릭서에서는 모든 값이 불변이다.
> * 배열을 수정하거나 해도 새로운 배열로 복사된다.
> * 이를 통해 동시성 처리에 유리하다.
> * 데이터의 복사에 따른 비용은 작은 프로세스 단위로 해서 힙 영역의 크기를 줄이거나
>   기존 데이터를 참조하는 형식의 복사를 통해 비용을 줄인다.


#### 자료형
###### 내장 자료형
>값 타입
>* 정수: 저장할 수 있는 크기의 제한이 없으며, 10진수 외에 16진수(0x), 8진수(0o), 2진수(0b) 를 값 앞에 붙여 표현할 수 있다. 또한 큰 크기의 숫자를 100_000 과 같이 언더스코어로 자릿 수를 구분해 표현할 수 있다.
>* 실수: 부동소수점 방식 IEEE 754 배정밀도 형식을 따른다.
>* 아톰: 다른 언어의 상수 문자열과 비슷한 역할을 수행하는 자료형
```elixir
:abc123
:<>123/aw
:"asd123"
```
> * 범위: start...end 방식으로 작성하는 2개의 정수 값과 사이의 연속된 값을 표현하는 자료형
>   1.12 버전부터는 start...end\/\/step 방식으로 숫자를 건너뛰는 범위를 만들 수 있다.
> * 정규식: ~r{정규표현식}, ~r{정규표현식}옵션

>시스템 타입
>* 프로세스 ID: 프로세스 고유 식별자
>* 포트: 외부 프로세스와 통신을 위해 사용되는 추상화 인터페이스
>* 레퍼런스: 고유 값을 생성하기 위한 자료형

>컬렉션 타입
>* 튜플: 상수형 리스트, 생성된 후 값을 변경하거나 추가, 삭제가 불가능 {} 중괄호를 이용해 표현
>* 리스트: 링크드리스트의 형태를 가진 자료형, 머리는 값 꼬리는 다른 리스트를 가지는 방식의 리스트
>   임의의 위치의 값에 접근하는 속도가 느리다. [] 대괄호를 이용해 표현
>* 키워드 리스트: 키-값 쌍으로 이루어진 리스트
>   2-튜플형식의 리스트로 변환된다.
```elixir
[name: "Tom", city: "DE"] # 단축문법
[{:name, "Tom"}, {:city, "DE"}] # 실제 변형된 값
```
>* 맵: 키 값으로 이루어진 자료형
>	* 키로 문자열, 튜플, 아톰 등을 지원한다.
>	* 키워드 리스트와 차이는, 맵은 키가 중복될 수 없다.
>	* %{key=> value} 의 형태를 가진다.
>	* 아톰을 키로 사용할 경우 앞에 :이 생략된다, 
>	   키가 아톰인 경우 %{name: "Tom", age: 15} 형식으로 표현할 수 있다.
```elixir
# 선언 및 키에 접근
person = %{"name"=>"Tom"}
person["name"] # 값이 없을 경우 nil 반환
person2 = %{name: "Tom"}
person2[:name] # 키가 아톰일 경우 앞에 : 를 표기
person2.name # . 을 통해 접근 가능, 단 점을 통해 호출할 경우 없으면 오류 발생
```
>* 바이너리: 이진 데이터를 표현하는 데 사용되는 자료형 <<데이터>> 형식으로 표기
>   <<데이터::size(비트수)>> 와 같이 데이터의 크기도 지정 가능
>* 날짜와 시간: 1.3 이후 생긴 날짜와 시간을 다루는 타입

> 참과 거짓 그리고 연산자
> * 참과 거짓: true, false, nil 이 있고 false, nil 이 아닌 모든 값은 참이다.
> * 연산자
> 	* 비교 연산자
> 		* a === b 값과 자료형 모두 일치해야 참
> 		* a !== b 값과 자료형 하나라도 다르면 참
> 		* a == b 값이 같으면 참
> 		* >, < 의 비교 연산이면 일반적으로 비교 가능한 연산이면 연산자대로 처리되고 아니면
> 		  다음과 같은 규칙을 따른다.
> 			* 숫자 < 아톰 < 레퍼런스 < 함수 < 포트 < 프로세스ID < 튜플 < 맵 < 리스트 < 바이너리
> 	 * 연결 연산자
> 		 * 바이너리 연결: <<1, 2>> <> <<3, 4>> 
> 		 * 리스트 연결: list1 ++ list2 
> 		 * 리스트1을 복사해서 리스트2에 포함된 값들 제거: list1 -- list2
> 	 * in 연산자: a in enum a 가 enum 에 있는지 확인, map일 경우는 a가 {키, 값} 형식의 튜플형식 필요
> 	 * 정규식 확인 연산자:  문자열 =~ 정규식 형태로 사용하며 문자열이 정규식 패턴에 일치하는지 확인해서 참, 거짓을 반환
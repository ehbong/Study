# OS
* [인터럽트, 시스템 콜](https://velog.io/@klm03025/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C)
* [프로세스, 스레드 설명 유튜브](https://www.youtube.com/watch?v=iks_Xb9DtTM)
* [프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

> Process  
> 프로그램이 실행되는 상태 최소 1개의 thread 를 가짐  
> * Process 생명주기
>   1. 프로세스 생성을 위한 공간을 할당하고 PCB(Process Control Block)를 생성 및 초기화하며, 실제메모리를 가상화한 가상메모리를 할당받음  
>      이때 PCB의 프로세스 상태값을 New로 설정
>   2. 프로세스 초기화, 코드, 데이터, 스택 등 초기메모리 영역 설정 및 프로그램카운터가 첫 명령어 주소를 가르키도록 설정
>   3. 초기화가 완료되면 프로세스 상태를 Ready로 변경하고, Ready Queue에 등록
>   4. 디스패처에 의해 선택된 순서가 되면 프로세스가 실행되고 상태를 Running으로 변경
       (디스패처는 준비상태의 프로세스 중 실행할 프로세스를 선택하는 기능을 수행)
>   5. 시간 할당량이 지나면 Ready상태로 변경, 입출력 요청이 발생하면 Waiting 또는 Block 상태가 되었다가, 끝나면 Ready상태로 변경  
       (입출력 요청 때 NonBlock일 경우 Wait 없이 계속실행)
>      (실행에서 상태가 변경될 때, Context Switching이 일어나고, 이 때 PCB에 진행중이던 정보를 저장)
>   7. Ready Queue에 다시 등록되었다가, 순서가 되면 다시 실행되고 모든 작업이 완료되면 프로세스가 종료
     운영체제는 PCB를 삭제하고, 할당한 가상메모리를 해제, 종료 코드는 부모프로세스에게 전달

> PCB(Process Control Block)  
> 운영체제가 프로세스를 관리하기 위한 정보를 포함하는 공간  
> * 내부 구조
>   * 프로세스의 식별자(Process ID)
>   * 프로세스 상태(Process State)
>   * 프로그램 카운터(실행할 명령어의 주소를 카르키는 포인터),
>   * 레지스터 상태(실행중인 프로세스의 CPU의 레지스터 상태, Context Switching이 일어날 때 진행중인 작업을 저장)
>   * 스케줄링 정보(우선순위, 할당된 CPU시간 정보 등)
>   * 메모리 관리 정보(가상메모리 주소 공간 또는 실제 메모리 할당 정보 등)
>   * 자원할당 정보(메모리, 파일, IO장치 등 정보 및 위치, 상태 여부)
>   * 계정 정보(프로세스 실행 시간, CPU 사용량, 입출력 작업 수 등) 



> Thread  
> 스레드는 프로세스를 구성하는 작은 실행 단위로서, CPU에서 처리되기 위한 단위입니다. 프로세스는 스레드의 집합  
> 모든 프로세스는 하나 이상의 스레드를 가지고 있음

> TCB(Thread Control Block)
> 스레드의 관리 및 정보를 저장하는 구조체
> 리눅스에서는 Task Control Block으로 불리기도하고,  
> Window에서는 ETHREAD(Executive Thread Object), KTHREAD(Kernel Thread Object)로 사용된다.  
> TCB의 상태는 실행, 준비, 대기, 종료가 있으며,  
> 프로세스의 상태는 스레드의 상태를 따라가는데 이때 스레드 상태의 우선순위는 실행, 준비, 대기, 종료 순이다.  
> 즉 1개라도 실행이면 실행, 실행을 제외하고 1개라도 준비라면 준비,... 방식이다.


> fork
> 프로세스 생성을 위한 방법 중 하나
> 프로세스를 복제해서 프로세스를 생성 비용을 줄이는 방법
> 복제 대상인 프로세스와 부모자식 관계를 가짐
> 예) 크롬에서 새로운 탭 생성

> exec
> 기존 프로세스를 새로운 프로세스로 대체하는 방법
> PCB를 재활용하고 사용자 영역의 데이터는 초기화해서 새로운 프로세스로 변경
> 기존 PID 및 부모를 계승함

### 스케줄러
> 고수준 스케줄러  
> 새로운 프로세스를 우선순위, 리소스 현황 등을 고려한 실행 결정단계  

> 중간수준 스케줄러
> 메모리에 올라온 프로세스 중 메모리 스왑 인, 아웃을 하는 단계
> 주로 메모리 부족 시 실행

> 저수준 스케줄러 
> 메모리에 올라온 프로세스 중 준비 상태의 프로세스를 실행 시키는 단계
> 실제로는 스레드 단위로 진행


### IPC(inter-process call)
> 목적  
> * 데이터 공유: 프로세스간의 데이터 공유
> * 프로세스간 통신: 서로 상호작용을 위한 통신
> * 동기화: 데이터 접근 및 수정 시 충돌 방지

> 기법
> * 파이프: 단방향 통신 채널로 부모와 자식프로세스 간에 사용
> * 메시지 큐: 양방향 통신, 프로세스 간 통신에 사용
> * 공유 메모리: 두개 이상의 프로세스가 같은 메모리 영역을 공유해서 사용(전역 변수와 비슷)
> * 네트워크: 네트워크 통신을 활용한 방법, 소켓 및 RPC(remote procedure call) 등을 사용

#### 동시성 제어
* [뮤텍스, 세마포어 차이](https://heeonii.tistory.com/14)
> 뮤텍스
> * 한번에 하나의 스레드만이 락을 획득 할 수 있게 하는 방법
> * 다른 스레드가 락을 획득하려면 사용중인 스레드가 락을 해제해야 함
> * 이진 세마포어로 구현  

> 세마포어
> * 동시에 허용하는 스레드 수를 지정해서 사용하는 방법
> * N개의 스레드 작업을 생성해 놓고, 과부하를 막기 위해 특정 스레드 수 만 동작하도록 제어할 수 있음
> * 공유변수에 값을 변화시키는 것에는 동기화 이슈때문에 적합하지 않음(뮤텍스를 활용)
> * 특정 자원에 접근을 제어하고 동기화 하는데 사용


### 메모리
> 절대주소,  상대주소
> |구분|절대주소|상대주소
> |----|-------|-------|
> 관점|메모리 관리자 입장|사용자 프로세스 입장
> 주소시작|물리주소 0번지|물리주소와 상관없이 항상 0번지
> 주소공간|물리 주소(실제주소) 공간|논리 주소 공간(가상메모리)
> 
> 절대 주소는 특별한 변환 과정 없이 바로 접근,  
> 상대주소는 메모리 관리자의 재배치 레지스터를 통해 절대주소로 변환되어 접근

##### 가상메모리
> * 사용이유
>   * 메모리 의존성 제거: 시스템 사양에 따라 메모리 용량이 다른 부분을 가상메모리를 통해 극복  
                         메모리 관리자가 1차메모리와 2차메모리의 swap영역을 합쳐서 물리 메모리보다 큰 용량 사용 가능
>   * 프로세스 격리: 프로세스 간 상호 격리로 보안 강화, 잘못된 접근으로 인한 메모리 충돌 방지
>   * 메모리 관리: 메모리 관리자가 매핑 테이블을 이용, 메모리 관리 용이
>  
> * 매핑 테이블을 사용해서 프로세스의 가상메모리와 물리 메모리 주소를 연결
> * 메모리 분할 방식으로 세그먼테이션, 페이징을 혼용해서 사용
> * 세그먼테이션: 가변 분할방식으로 논리적 크기에 따라 메모리 공간을 분리하는 방법으로,  
>                프로세스 종료시 메모리 외부 단편화가 발생함(각각 프로세스마다 사용 공간이 다름으로, 빈 공간 발생)
> * 페이징: 고정 분할방식으로 일정한 크기에 따라 메모리 공간을 분리하는 방법으로,  
>           20kb를 제한으로 지정했을 시 20kb로 나누고 나머지에 대해 최소 20kb 공간을 잡아야 하므로 빈공간이 발생 이를 메모리 내부 단편화라고함
